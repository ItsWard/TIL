## 스프링 탄생 배경

<br>
스프링이 없던 시절 EJB가 있었다.<br>
EJB는 개발자들이 개발하기에 굉장히 복잡하고, 작업에 따른 비용은 비쌌으며, 느린 기술이였다.<br>
<br>
그래서 차라리 POJO(Plain Old Java Object)를 사용하자(오래된 자바 오브젝트를 사용하자는) 이야기가 나올정도로 복잡했다.<br>
<br>
또한 당시 ORM 기술인 엔티티빈은 수준이 낮았었다.<br>
<br>

## 스프링이란? 

<br>
스프링 생태계는 다음과 같이 이루어져 있다.
<br>
> 핵심 기술 : 스프링 DI 컨테이너, AOP, 이벤트 <br>
> 웹 기술 : 스프링 MVC, 스프링 WebFlux<br>
> 데이터 접근 기술 : 트랜젝션, JDBC, ORM / XML 지원<br>
> 기술 통합 : 캐시, 이메일, 원격<br>
> 테스트 : Junit 스프링 기반 테스트<br>
등...<br>
Spring DI Container, AOP, Event같은 핵심 기술부터 Spring MVC, DB 접근 기술은 트랜잭션, JDBC, ORM, XML도 지원한다.<br>
결국 여러 스프링 생태계에서 생성 배포된 여러 기술들을 한데 뭉쳐 사용할 수 있게 해주는 프레임워크를 스프링 프레임워크라 할 수 있다. <br>
<br>
<br>

## 스프링 부트

<br>
최근은 Spring Boot에 톰캣 웹 서버를 내정하여, 웹서버를 설치하지 않아도 빌드, 서버까지 사용할 수 있다.(이전에는 톰켓서버를 연결하고 .. 많은 설정이 필요하였다)<br>
스프링 프레임워크와 서드파티 라이브러리를 자동으로 구성해준다(Maven / Gradle)<br>
운영환경의 모니터링이 굉장히 중요한데 이를 기본적으로 제공한다.<br>
<br>
예시1 : 운전자가 K3를 타다가 아반때 혹은 테슬라로 변경하여도, 운전자는 운전 할 수 있다.<br>
<br>
운전자는 자동차(역할)이라는 인터페이스를 알고있기 때문에, 차가 바뀌어도 활용할 수 있다.
<br>
실제로 자동차가 어떻게 구현되었는 지, 어떤 소재로 이루어져 있는지 알 필요 없이, 클라이언트는 새로운 자동차가 출시되어도
자동차 운전방법을 새로 배울필요가 없다.<br>
<br>
예시2 : 대본을 맡은 배우가 바뀌어도 공연이 가능하다.<br>
.<br>
공연에서는 역할과 구현이 나누어져 있다. -> 대본과 배우가 나누어져 있다.<br><br>
로미오 - 장동건 / 줄리엣 - 김태희 가 해도
로미오 - 원빈 / 줄리엣 - 송혜교 가 해도 혹은 누가 오든간에 공연은 진행 될 수 있다.<br>
<br>
공연에 역할(대본)은 정해져 있기때문에, 대본을 구현하는 배우는 **대체** 할 수 있어야 한다.<br>
이것이 역할과 구현을 분리하면 유연하고 변경이 용이하다는 의미이다.<br>
<br>
프로그램을 유연하고 변경에 용이하게 만드는 방법 → 다형성 <br>
다형성은<br>
 <br>
> SPR(Single Responsibility Principle) : 단일 책임 원칙<br>
> OCP(Open Closed Principle) : 개방 폐쇄 원칙<br>
> LSP(Liskov Substitution Principle) : 리스코프 치환 원칙<br>
> ISP(Interface Segregation Principle) : 인터페이스 분리 원칙<br>
> DIP(Dependency Inversion Principle) : 의존 역전 원칙<br>
<br>

**SPR(Single Responsibility Principle)** 단일 책임 원칙
<br>
하나의 클래스는 하나의 책임만 가져야한다.<br>
기능을 변경하여도, 다른 프로그램에 영향을 최소한으로 주어야한다.
<br>

**OCP(Open Closed Principle)** 개방 폐쇄 원칙
<br>

소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀 있어야 한다.<br>
역할과 구현을 분리한 예시를 떠올려보면, 운전자는 차가 아우디은, K3든 바뀌어도 운전이 가능 해야 한다.<br>
<br>
기능이 동일하다면, 클라이언트는 영향을 받지 않고 사용이 가능해야 한다.<br>
Spring에서는 스프링 컨테이너 / DI를 이용하면, OCP원칙을 지키면서 기능을 구현할 수 있다.<br>
<br>

**LSP(Liskov Substitution Principle)** 리스코프 치환 원칙<br>
<br>
프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않고, 하위타입의 인스턴스로 변경이 가능해야한다.<br>
<br>
다형성에서 하위클래스는 인터페이스 규약을 지켜, 인터페이스를 구현한 구현체를 믿고 사용할 수 있어야한다는 것.
예를들어 자동차에서 전진 기능을 담당하는 ```run``` 메서드를 구현하였다면 +10(앞으로 간다고 가정하자) 이 되어야하는데 -10(뒤로 간다고 가정하자)으로 간다면LSP 위반이다. <br>
단순하게 컴파일에 성공하는 것이 아니라, 기능의 구현이 메서드의 존재 의미에 맞게 기능적으로 보장해야한다. <br>
<br>

**ISP(Interface Segregation Principle)** 인터페이스 분리 원칙<br>
<br>
자신이 사용하지 않는 인터페이스는 구현하지 말아야한다. <br>
-> 하나의 일반적인 인터페이스 보다는 여러 개의 구체적인 인터페이스가 낫다라는 뜻이다.<br>
 
> 자동차 인터페이스 (기능이 모두 들어감) <- 너무 큰 덩어리<br>
> 자동차 운전 인터페이스 / 정비 인터페이스 / ... <- 정비 관련 역할이 변하더라도, 운전에 영향을 미치지 않는다.<br> 
<br>
인터페이스를 적당한 규모로 쪼개는 것이 명확하고, 대체하기에 좋다. <br>
<br>

**DIP(Dependency Inversion Principle)** 의존 역전 원칙<br>
<br>
프로그래머는 추상화(인터페이스)에 의존하고, 구체화(구현 클래스)에 의존하면 안된다.<br>
'역할'에 의존해야한다는 동일한 이야기 이다.<br>

DIP는 복잡한 컴포넌트들의 관계를 단순화하고, 컴포넌트 간의 커뮤니케이션을 효율적이게 하는 것을 중요하게 여긴다.<br>
<br>
## 객체 지향 설계와 스프링 <br>
<br>
스프링은 의존성 주입을 스프링 컨테이너를 제공함으로서, 부품을 교체하듯 개발할 수 있게 도와준다.<br>
우리는 설계에 역할과 구현을 분리하여야 한다. 이상적으로는 모든 설계에 인터페이스를 부여하는 것이 좋지만, 추상화라는 비용이 발생한다.<br>
기능을 확장할 가능성이 없다면, 구체 클래스를 사용하되, 이후 필요할 때 리팩터링을 통해 인터페이스를 도입하도록 한다.<br>
예시 코드 Car<br>
<br>

```C
public interface Car {
	void driving(DirectionType direction);
	void fix(FixType type);
 
}
```

<br>
한번에 모든 기능을 가진 Car <br>
<br>

```C
public interface Car {
	void go();
	void left();
	void stop();
	void right();

	void fixHandle();
	void fixEngine();
}
```

<br>
구현 기능에 맞춰 나눈 Drive / Fix <br>
 <br>
 
```C
public interface Drive {
	void go();
	void left();
	void stop();
	void right();
}

public interface Fix {
	void fixHandle();
	void fixEngine();
}
```

<br>

DIP(Dependency Inversion Principle): 의존관계 역전 원칙<br>
: 구체화가 아닌 추상화에 의존해야한다는 원칙.<br>
이 원칙은 구현보다 역할에 집중하라는 것으로 역할에 집중함으로써 내부 구현이 바뀌더라도 인터페이스(역할)만 의존하게 되면 기능의 변경 / 확장이 유연해질 수 있다. <br>
<br>
스프링을 사용하지 않고 기본 자바 코드를 작성하다보면 SOLID 원칙을 모두 지키기 힘들다. <br>
<br>

```C
@Service
public class MemberService {
	private MemberRepository memberRepository = 
			new MemoryMemberRepository();

	...
}
```
<br>

 memberRepository에 할당되는 객체 인스턴스를 생성하기위해 특정 구현체에 의존하는 코드이다. <br>
<br>
DIP 원칙에서 구체화가 아닌 추상화에 의존해야 한다는 원칙을 못 지킨 것을 알 수 있다. <br>
<br>
<br>
리포지토리 구현체를 메모리에서 사용하는 JDBC를 사용하는 리포지토리를 사용하게 하려면 new JdbcMemberRepository()로 변경을 해야한다.<br>
하지만 이렇게 구현할 굥우 OCP원칙인 변경에 닫혀있지 못한다. <br>

즉 다형성만 가지고는 OCP, DIP를 지킬 수 없다. <br>
→ 그래서 스프링을 이용하면 스프링의 다음 기술로 다형성 + OCP, DIP를 지킬 수 있게 된다.<br>
⇒ DI(Dependency Injection): 의존관계, 의존성 주입<br>
⇒ DI Container 제공<br>
<br>
<br>


관심사의 분리 <br>
각각의 계층(Service, Controller, Repository)는 다른 역할의 구현체를 사용하고자 할 때 그 구현체의 생성자를 호출하여 객체 인스턴스를 만들어 해당 인스턴스에 의존을 하게 되는데, 이 과정에서 구현체에 대한 의존성이 생기게 되면서 여러 객체지향 원칙들을 어기게 된다. <br>
각각의 계층의 구현체들은 자기 자신의 책임만 해결하도록 해야하는데, 다른 역할의 구현체까지 알게되는건 과도한 책임이라 할 수 있다. <br>
<br>
<br>
그래서 관심사를 분리하여 각각의 역할이 자신의 책임에만 관심을 가질 수 있도록 해줘야 한다. <br>

### AppConfig <br>
<br>
그럼 아예 이런 구현체를 생성하여 연결(주입)해주는 책임만을 담당하는 별도의 역할 만든다.<br>
해당 객체에서는 OCP, DIP 원칙을 위배하게 하는 각각의 구현체에서 다른 역할의 구현체를 의존하게 하는 부분들을 없앨 수 있도록 해줄 수 있다.<br>
<br>

```C
AppConfig
public class AppConfig {

    public MemberService memberService() {
        return new MemberServiceImpl(new MemoryMemberRepository());
    }

    public OrderService orderService() {
        return new OrderServiceImpl(new MemoryMemberRepository()
																		,new FixDiscountPolicy());
    }
}
```

<br>
<br>

## 클래스 다이어그램<br>

<br>
MemberService의 구현체인 MemberServiceImpl에서는 MemberRepository의 구현체를 알 필요 없이 AppConfig에서 주입해주는 구현체만 받아 사용하면 된다. <br> 
그리고 이런 모습을 외부(AppConfig)에서 주입(Injection)받는 것 같다고 하여 의존관계 주입 혹은 의존성 주입이라 부른다.<br>
<br>

## IOC, DI Container <br>
<br>
**IoC(Inversion of Control) 제어 역전** <br>
: 기존에 구현체에서 필요한 구현체를 직접 생성해 연결 및 사용하던 방식(new Car... )에서 외부에서 주입해주는 역할을 가져와 사용하게 되면서 자기 자신의 책임에만 관심을 가져도 되도록 관리되도록 하는 것을 제어의역전(IoC)라 한다.<br>
<br>

**DI(Dependency Injection) 의존관계 주입** <br>
: 런타임 시점에 외부에서 실제 구현체를 생성 및 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결되는 것을 의존관계 주입이라 한다. <br>
그리고 정적인 클래스 의존관계와 동적인 객체 인스턴스 의존관계에 대해 이해할 필요가 있다.<br>

<br>
**정적인 클래스 의존관계** <br>
<br>
클래스상단에 작성되있는 import 코드만 보고도 판단이 가능한 의존관계.<br>
애플리케이션을 실행하지 않아도 분석이 가능하지만 역할의 실제 구현체가 무엇이 사용될지는 알 수 없다.<br>
<br>
**동적인 객체 인스턴스 의존 관계** <br>
<br>
<br>애플리케이션 실행 시점에서 실제로 생성된 인스턴스의 참조값이 연결된 실제 의존관계.<br>
<br>

**DI Container** <br>
<br>객체를 생성,관리,연결해주는 것을 IoC 컨테이너 혹은 DI 컨테이너라 한다. <br>
<br>

**스프링 컨테이너** <br>
<br>
<br> 일반적으로 ApplicationContext 를 스프링 컨테이너라 한다.<br>
<br>스프링 컨테이너에 등록된 객체를 스프링 빈이라 한다. <br>
<br> 스프링 빈은 @Bean 이 붙은 메서드의 이름을 스프링 빈의 이름으로 사용한다. <br>
<br>

```C
@Bean
public MemberRepository memberRepository(){
	return new MemoryMemberRepository();
}
```

<br>
<br>

→ memberRepository가 스프링 빈의 이름이 된다.<br>
<br>
<br>
<br>

개발자가 별도로 AppConfig 같은 DI Container를 만들지 않아도 된다.<br>
ApplicationContext는 인터페이스이고, 다형성을 적극 사용한다. <br>
<br>
ApplicationContext의 상위 구조에는 BeanFactory라는 컨테이너가 존재하지만, 일반적으로 BeanFactory를 직접 사용하는 일은 드믈기에 ApplicationContext를 스프링 컨테이너라 한다. <br>
<br>

## 스프링 빈 등록
<br>
<br>
AppConfig의 빈 정보를 읽어와 등록하는 공간이다.
<br>

둘 이상의 동일한 타입이 스프링 빈을 조회하는 경우 NoUniqueBeanDefinitionException이 발생한다.<br>
<br>
메서드 이름 명시적으로 호출을 하거나, ```getBeans``` 메서드를 통해 Map에 스프링 빈 컬렉션을 받을 수 있다<br>
<br>

상속관계인 스프링 빈을 조회한다면, 내가 조회하고자 하는 스프링 빈과 해당 빈을 상속하는 하위 빈들까지 전부 조회한다.<br>
이 경우에도 getBean으로 조회할 때 하위 스프링 빈이 둘 이상 있다면 중복 오류가 발생한다.(NoUniqueBeanDefinitionException)<br>
<br>
동일한 타입의 스프링 빈이 여러개일때와 동일하게 명시적인 이름이나 getBeansOfType 메서드를 통해 컬렉션으로 반환받을 수 있다.<br>
ApplicationContext라는 스프링 컨테이너는 BeanFactory라는 최상위 스프링 컨테이너 역할에 추가적인 기능을 덧붙혀 제공하는 인터페이스라 볼 수 있다. <br>
그래서 해당 인터페이스를 보면 BeanFactory뿐 아니라 MessageSource, EnvironmentCapable 등 여러 인터페이스를 다중 상속하여 다양한 부가기능을 함께 제공한다. <br>
<br>
<br>

## 스프링 빈 설정 메타 정보 - BeanDefinition <br>
<br>
스프링 컨테이너 생성시 필요한 설정들은 한 가지의 형식이 아닌 Java, XML, Groovy등 다양한 형식으로 모두 제공이 가능하다. 이게 가능한 이유가 BeanDefinition 인터페이스 덕분이다. <br>
<br>
각각의 설정정보에 맞는 BeanDefinitionReader를 사용해 해당 설정정보를 읽어서 BeanDefinition 메타정보를 생성해 전달한다. <br> 
<br>
<br>

## 싱글톤 컨테이너
<br>
<br>

```C
AppConfig의 문제점
public class AppConfig {

    public MemberService memberService() {
        return new MemberServiceImpl(new MemoryMemberRepository());
    }

    public OrderService orderService() {
        return new OrderServiceImpl(new MemoryMemberRepository()
																		,new FixDiscountPolicy());
    }
}
```

<br>
<br>

<br> AppConfig클래스는 메서드를 호출해서 자연스럽게 역할의 구현체를 주입받을 수 있다는 장점이 있지만, 메서드 호출시마다 새롭게 인스턴스를 만드는 문제가 있다. <br> 
만약 여러개 클래스에서 호출을 할 경우 모두 각각의 인스턴스를 생성해서 주입해줄 것이고 문제가 발생한다.
<br>
<br>
이는 싱글톤 패턴을 사용해서 객체를 재활용 할 수 있도록 하여야 한다. <br>
<br>

그렇다고 모든 클래스가 싱글톤 패턴으로 만들면안된다.<br>
싱글톤은 말 그대로 하나의 인스턴스를 모든 클라이언트에서 바라보게하고 사용할 수 있도록 하는 것이기에 지켜야 하는 게 있다. 바로 무상태성(stateless)이다. <br>
싱글톤 패턴을 사용할 객체는 무상태성(stateless)를 보장해야 한다. <br>
<br>

```C
public class MemberService {
		private final String serviceName;
		private String memberCount;

	...
}
```

<br>

MemberService가 서비스명, 멤버수 라는 상태를 가지고 있는 상태에서 싱글톤 패턴을 적용하면 스레드 안전하지 못하기에 문제가 발생할 수 있다. 
<br>
<br>

## 싱글톤 패턴의 문제점<br>
<br>
싱글톤 패턴은 장점만 있는게 아니라 여러 문제점 역시 가지고 있다. <br>
1. 싱글톤 패턴을 적용하기 위한 추가 코드를 작성하는데 드는 비용, 클라이언트가 구현체에 의존하면서 DIP를 위반하게 된다.<br>
2. 테스트가 어려워진다.<br>
3. 초기화가 어렵다.<br><br>
4. private 생성자로 자식 클래스를 만들기 어렵다.<br>
5. 유연성이 떨어진다.<br>
6. 안티패턴으로 불리기도 한다. <br>
<br>
<br>

**스프링 컨테이너** 로 싱글톤 방식의 문제를 해결할 수 있다.<br>
<br>
스프링 컨테이너는 싱글톤 컨테이너의 역할을 할 수 있고, 싱글톤 패턴이 가지는 문제점을 모두 해결해준다. <br>
<br>
@Configuration 애노테이션을 사용하는 설정 클래스에서 등록되는 스프링 빈들은 모두 스프링 컨테이너에 의해 싱글톤으로 관리가 된다.  <br>
클래스 내부에 동일한 객체를 생성하는 코드가 중복 호출되더라도 하나의 인스턴스로 관리되어 싱글톤이 유지된다. <br>
<br>
<br 
## CGLIB를 이용한 싱글톤 컨테이너 관리 <br>

**CGLIB**
<br>
<br>
코드 생성 라이브러리(Code Generator Library)로 런타임시에 동적으로 자바 클래스의 프록시를 만들어주는 기능을 제공한다. <br>
대표적으로 Hibernate에서는 자바빈 객체에 대한 프록시를 생성할 때 사용돠고, Spring에서는 스프링 컨테이너 혹은 프록시 기반 AOP를 구현할 때 주로 사용된다.  <br>
CGLIB는 기존 소스코드에 추가기능을 덧붙히는 기존 객체의 하위 객체인 프록시 객체를 만드는데 사용이 되는데, 이를 이용해 스프링은 싱글톤을 유지할 수 있도록 한다. <br>

<br>
<br>

## @Configuration이 없는 클래스에서 @Bean 등록을 하는 경우<br>

<br>
@Configuration 애노테이션이 없는 설정 클래스에서도 스프링 빈을 등록할 수는 있다. <br>
하지만, CGLIB으로 하위 객체가 만들어서 스프링 컨테이너로 관리되지 않기에 싱글톤이 보장되지 않아, 동일한 인스턴스가 여러번 생성될 수 있다. <br>
<br>
<br>
